# Livora Integration & Operation Manual

**Purpose:**
This manual explains, step‑by‑step, how to integrate any client (with or without their own UI) into the Livora Enterprise Intelligence Engine and how to operate the system day‑to‑day. It is written for engineers, product owners, and client success managers.

> **Scope:** Full technical integration options, event contracts, SDK usage, API contracts, deployment patterns (client‑cloud or Livora‑managed), QA checklist, runbooks, monitoring, governance, and handover artifacts. No pricing or time estimates included.

---

## 1. Integration modes (choose one)
1. **Full Integration (Recommended)** — Livora builds or owns the frontend (website + mobile + CRM desktop) and deploys the engine into the client cloud or Livora‑managed environment. Best for highest data quality and fastest feature rollout.
2. **BI‑Only Integration (Event Feed)** — Client keeps their frontend; they push canonical events to Livora ingestion endpoints. Livora provides dashboards, automation, and campaign delivery.
3. **Connector / Pull Integration** — Livora uses connectors (Shopify, ERP, DB replication, webhook adapters) to pull data and turn records into events.
4. **Hybrid** — Some parts (e.g., orders) are pushed via webhooks; other parts are pulled via connectors.

Choose the mode during Discovery and document it in the Integration Blueprint.

---

## 2. Pre‑integration checklist (must complete before dev)
- [ ] Signed data access & processing agreement (client data ownership clarity)
- [ ] Client cloud account details and IAM cross‑account role plan (if deploying to client cloud)
- [ ] Decide deployment model: Client cloud (preferred) OR Livora managed
- [ ] Exchange API keys and secure secrets channel (Secrets Manager / Vault)
- [ ] Agree on canonical event schema and version to use
- [ ] Provide product catalog mapping (product_id, sku, categories)
- [ ] Identify compliance requirements (PCI, HIPAA, GDPR) and list PII constraints

---

## 3. Canonical Event Contract (mandatory)
All integrations must adhere to the canonical schema. Use the schema registry to manage versions.

```json
{
  "event_id": "uuid-v4",
  "timestamp": "2025-11-02T12:34:56Z",
  "client_id": "client_xyz",
  "user_id": "auth|1234",          
  "anon_id": "device|abcxyz",
  "session_id": "sess|9876",
  "event_type": "product_view",
  "props": { "product_id":"SKU-001", "price":129.00, "currency":"INR" },
  "context": { "ip":"1.2.3.4", "ua":"...", "locale":"hi-IN" }
}
```

**Rules:**
- `event_id` and `timestamp` are mandatory.
- Use consistent `product_id` mapping across systems.
- If PII is present, include a tokenized reference; store full PII in encrypted Aurora only if required.

---

## 4. SDKs & Client Implementation
**Livora provides SDKs** for: Web (JS), React Native, Android (Kotlin), iOS (Swift), and a lightweight server SDK (Node/Python).

**SDK responsibilities:**
- Collect events and buffer them (batching) to reduce network calls.
- Retry with exponential backoff on 5xx or network errors.
- Persist events locally when offline and flush on reconnect.
- Attach stable identifiers: `anon_id`, `session_id`. Stitch `anon_id` -> `user_id` on auth.
- Provide helper methods for common events: `trackProductView()`, `trackAddToCart()`, `trackPurchase()`.

**Quick integration steps (frontend dev):**
1. Install Livora SDK and import into app.
2. Initialize with client token and environment (staging/prod).
3. Send `identify(user)` when user logs in.
4. Wrap product interactions with `Livora.track()` calls.
5. Ensure events flush on page unload or app background.

---

## 5. Ingestion API & Delivery Guarantees
**Main endpoint:** `POST /v1/events`
- Accepts batched up to 100 events.
- Header: `Authorization: Bearer <token>`, `X-Client-Id: <client>`
- Returns `202 Accepted` with a list of offsets for accepted items.

**Delivery model:**
- Events are accepted and stored in the streaming layer (Kinesis/PubSub).
- Best effort ordering guaranteed per session via partition key = `session_id`.
- Deduplication done on `event_id` at enrichment layer.

**Failures & DLQ:**
- Invalid events -> 400 returned with validation errors.
- If consumer fails to process, events go to DLQ (SQS/SNS) and a retry policy is applied.

---

## 6. Stream Processing & Enrichment (Livora Engine)
**Flow:** Ingress → Enrich Lambda / Flink → Write to DynamoDB (operational) + Firehose → S3 (raw)

**Enrichment tasks:**
- IP → geo mapping
- UTM normalization
- User profile merge (if `user_id` appears later)
- Compute session metrics (session duration, steps)

**Stateful writes:**
- Session and cart snapshots are updated in DynamoDB per `USER#` key.
- Use conditional writes to avoid race conditions.

---

## 7. Operational Stores Design
**DynamoDB single table pattern** with items keyed per user.
- PK: `USER#<user_or_anon>`
- SK: `SESSION#<id>` / `CART#` / `FEATURE#<name>`

**Aurora (CRM)** for relational objects:
- Contacts, Companies, Deals, Activities, Campaigns
- Use standard normalization for relational integrity

**Guidelines:**
- Keep large blobs in S3 and store references in DB.
- Use TTL for session items to avoid unbounded growth.

---

## 8. Analytics & Warehouse Mapping
**Raw events** -> S3 (Parquet) partitioned by date/hour.
**Curated datasets** -> Glue ETL jobs -> Redshift/BigQuery tables.
**Materialized views** for fast reads: funnels, cohorts, product metrics.

**Data access for frontend:**
- Do NOT allow CRM desktop app to query warehouse directly.
- Serve analytics via Read APIs backed by caches (Redis) and precomputed aggregates.

---

## 9. Campaign Engine Contract
**Campaign JSON model example (stored in CRM):**
```json
{
  "campaign_id":"camp_123",
  "trigger":"cart_abandonment",
  "schedule": [ { "delay_minutes":30, "action":"whatsapp_template:reminder" },
                { "delay_minutes":1440, "action":"email:coupon" } ],
  "audience_query":"select user_id from segments where added_to_cart = true and purchase=false"
}
```

**Execution:**
- Campaign Orchestrator reads campaign def and schedules tasks in Step Functions.
- Delivery workers call third‑party APIs.
- Delivery results posted back as `campaign_delivery` events.

---

## 10. Integration patterns for clients without UI
If a client does not want Livora to build UI, use one of the below:

### Pattern A — Push Events (Preferred)
- Client calls `POST /v1/events` directly from their system (server side) for every important action.
- Pros: Real-time, reliable, easy to validate.
- Cons: Requires client engineering time.

### Pattern B — Connector Pull
- Livora configures connectors to pull from 3rd party APIs (Shopify, Razorpay, ERP APIs). Connectors run on schedule.
- Pros: Low client work.
- Cons: Near real-time only, possible API rate limits.

### Pattern C — DB Snapshot / CDC
- If client has legacy DB, set up CDC (Debezium) to stream changes to Kafka/Kinesis and map to events.
- Pros: Full historical data possible.
- Cons: Requires infra on client side and mapping effort.

---

## 11. Security & Compliance Checklist
- Use JWTs and OAuth for API access.
- Enforce TLS everywhere.
- Encrypt S3, DynamoDB, Aurora using KMS.
- Keep secrets in a secrets manager.
- Implement data masking for PII in analytics layer.
- Maintain audit logs for campaign sends.

---

## 12. QA & Acceptance Tests (must pass)
- **Event fidelity test:** events from SDK → S3 raw -> sample processed aggregate matches expected counts.
- **End‑to‑end workflow test:** Add to cart → wait → automation triggers → delivery logged.
- **Backfill test:** historical data backfilled and aggregates produced identical to live data for sample window.
- **Security tests:** auth, API rate limiting, injection tests.

---

## 13. Runbooks & Operational Playbooks (examples)
**DLQ recovery:**
1. Inspect DLQ messages in SQS.
2. Fix invalid schema or missing data via enrichment patcher.
3. Replay messages to the stream after corrections.

**Shard scaling:**
- Monitor Kinesis iterator age → scale shards via autoscaling script.

**DynamoDB hot partition:**
- Identify hot key patterns and use synthetic sharding (append hash suffix).

---

## 14. Deliverables to hand to client at project end
- API docs (OpenAPI) for ingestion and read APIs
- SDK packages and usage guides
- QuickSight / dashboard links and embed tokens
- Runbooks, security audit report, and compliance statements
- Handover checklist with credentials and access controls

---

## 15. Support & Managed Operations (optional)
Livora can offer the following managed services:
- Platform monitoring & alerts
- Monthly analytics tuning & campaign optimization
- New feature rollout and model retraining
- On‑call support for critical incidents

---

## 16. Quick reference cheat sheet (copyable)
- Ingest URL: `POST https://ingest.livora.io/v1/events` (x-client-id, Authorization: Bearer)
- Required event fields: `event_id`, `timestamp`, `client_id`, `session_id`/`anon_id`, `event_type`.
- Campaign def table: `campaigns(campaign_id, trigger, schedule_json, audience_query)`

---

## Appendix A — Example integration timeline (phases only)
1. Discovery & mapping
2. Sandbox integration (events → S3 pass)
3. Pilot (small traffic, campaign tests)
4. Production cutover
5. Post‑launch optimization

---

## Appendix B — Contact points & escalation
- Platform lead: `platform@livora.tech` (for infra & onboarding)
- Integration engineer: assigned per client
- Support & incidents: `support@livora.tech` (pager duty)

---

*End of Manual — keep this document as the canonical integration guide for all client projects.*

